//go:build android || darwin || ios
// +build android darwin || ios

package main

// #include <stdint.h>
import "C"

import (
	"unsafe"

	"github.com/go-drift/drift/pkg/engine"
)

// DriftSkiaInitGL initializes a Skia GL context using the current GL context.
//
//export DriftSkiaInitGL
func DriftSkiaInitGL() C.int {
	if err := engine.InitSkiaGL(); err != nil {
		return 1
	}
	return 0
}

// DriftSkiaInitMetal initializes a Skia Metal context.
//
//export DriftSkiaInitMetal
func DriftSkiaInitMetal(device C.uintptr_t, queue C.uintptr_t) C.int {
	if err := engine.InitSkiaMetal(unsafe.Pointer(uintptr(device)), unsafe.Pointer(uintptr(queue))); err != nil {
		return 1
	}
	return 0
}

// DriftNeedsFrame returns 1 if a new frame should be rendered, 0 otherwise.
// Call this before acquiring a Metal drawable to skip unnecessary render cycles.
//
//export DriftNeedsFrame
func DriftNeedsFrame() C.int {
	if engine.NeedsFrame() {
		return 1
	}
	return 0
}

// DriftSkiaLastError returns a pointer to a C string describing the last Skia error.
// The native caller is responsible for freeing the returned string by calling free().
//
//export DriftSkiaLastError
func DriftSkiaLastError() *C.char {
	err := engine.LastSkiaError()
	if err == "" {
		return nil
	}
	return C.CString(err)
}

// DriftStepAndSnapshot runs the engine pipeline and returns platform view
// geometry as JSON. The caller must free *outData with C.free().
//
//export DriftStepAndSnapshot
func DriftStepAndSnapshot(width, height C.int, outData **C.char, outLen *C.int) C.int {
	data, err := engine.StepAndSnapshot(int(width), int(height))
	if err != nil {
		return 1
	}
	if len(data) == 0 {
		*outData = nil
		*outLen = 0
		return 0
	}
	cData := C.CBytes(data)
	*outData = (*C.char)(cData)
	*outLen = C.int(len(data))
	return 0
}

// DriftSkiaRenderFrameSync renders a frame using the split pipeline (after StepAndSnapshot).
// Geometry was already captured; this only composites into the GPU canvas.
//
//export DriftSkiaRenderFrameSync
func DriftSkiaRenderFrameSync(width, height C.int) C.int {
	if err := engine.RenderSkiaGLSync(int(width), int(height)); err != nil {
		return 1
	}
	return 0
}

// DriftSkiaRenderMetalSync renders a frame using the split pipeline (after StepAndSnapshot).
// Geometry was already captured; this only composites into the Metal texture.
//
//export DriftSkiaRenderMetalSync
func DriftSkiaRenderMetalSync(width, height C.int, texture C.uintptr_t) C.int {
	if err := engine.RenderSkiaMetalSync(int(width), int(height), unsafe.Pointer(uintptr(texture))); err != nil {
		return 1
	}
	return 0
}

// DriftSkiaPurgeResources resets GL state tracking and releases all cached GPU
// resources. Call after sleep/wake or surface recreation to prevent stale textures.
//
//export DriftSkiaPurgeResources
func DriftSkiaPurgeResources() {
	engine.PurgeSkiaGLResources()
}

// DriftShouldWarmUpViews returns 1 if the native embedder should pre-warm
// platform views at startup, 0 if warmup has been disabled.
//
//export DriftShouldWarmUpViews
func DriftShouldWarmUpViews() C.int {
	if engine.ShouldWarmUpViews() {
		return 1
	}
	return 0
}
