package workspace

import (
	"crypto/sha1"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/go-drift/drift/cmd/drift/internal/cache"
	"github.com/go-drift/drift/cmd/drift/internal/config"
	"github.com/go-drift/drift/cmd/drift/internal/scaffold"
	"github.com/go-drift/drift/cmd/drift/internal/templates"
)

// IsEjected returns true if platform has been ejected to ./platform/<platform>/.
// Uses strict validation - checks for multiple expected files to avoid false
// positives from stray or partial directories.
func IsEjected(projectRoot, platform string) bool {
	platformDir := filepath.Join(projectRoot, "platform", platform)

	switch platform {
	case "ios":
		// Require Runner/ to be a directory and project.pbxproj to be a file
		runner := filepath.Join(platformDir, "Runner")
		pbxproj := filepath.Join(platformDir, "Runner.xcodeproj", "project.pbxproj")
		runnerInfo, err1 := os.Stat(runner)
		pbxprojInfo, err2 := os.Stat(pbxproj)
		return err1 == nil && runnerInfo.IsDir() &&
			err2 == nil && !pbxprojInfo.IsDir()
	case "android":
		// Require settings.gradle and app/build.gradle to be files
		settings := filepath.Join(platformDir, "settings.gradle")
		buildGradle := filepath.Join(platformDir, "app", "build.gradle")
		settingsInfo, err1 := os.Stat(settings)
		buildGradleInfo, err2 := os.Stat(buildGradle)
		return err1 == nil && !settingsInfo.IsDir() &&
			err2 == nil && !buildGradleInfo.IsDir()
	case "xtool":
		// Require Package.swift and Sources/Runner/ to exist
		packageSwift := filepath.Join(platformDir, "Package.swift")
		sourcesRunner := filepath.Join(platformDir, "Sources", "Runner")
		packageInfo, err1 := os.Stat(packageSwift)
		sourcesInfo, err2 := os.Stat(sourcesRunner)
		return err1 == nil && !packageInfo.IsDir() &&
			err2 == nil && sourcesInfo.IsDir()
	default:
		return false
	}
}

// EjectedBuildDir returns the build directory for an ejected platform.
func EjectedBuildDir(projectRoot, platform string) string {
	return filepath.Join(projectRoot, "platform", platform)
}

// BridgeDir returns where bridge files should be written.
func BridgeDir(buildDir string) string {
	return filepath.Join(buildDir, "bridge")
}

// WriteDriftEnv writes a .drift.env file to the given directory containing
// absolute paths to the drift and go binaries. This file is read by driftw
// (bash, for Xcode and Android Studio on macOS/Linux) and driftw.bat
// (Windows, for Android Studio) to find both tools without relying on PATH.
// The file is machine-specific and should be gitignored.
func WriteDriftEnv(dir string) error {
	exe, err := os.Executable()
	if err != nil {
		return fmt.Errorf("failed to resolve drift executable path: %w", err)
	}
	exe, err = filepath.EvalSymlinks(exe)
	if err != nil {
		return fmt.Errorf("failed to resolve drift symlinks: %w", err)
	}

	var buf strings.Builder
	buf.WriteString("# Auto-generated by drift. Do not commit.\n")
	fmt.Fprintf(&buf, "DRIFT_BIN=%q\n", exe)

	if goBin, err := exec.LookPath("go"); err == nil {
		if goBin, err = filepath.Abs(goBin); err == nil {
			fmt.Fprintf(&buf, "GO_BIN=%q\n", goBin)
		}
	}

	return os.WriteFile(filepath.Join(dir, ".drift.env"), []byte(buf.String()), 0o644)
}

// JniLibsDir returns where Android native libraries go.
// For ejected builds: ./platform/android/app/src/main/jniLibs
// For managed builds: buildDir/android/app/src/main/jniLibs (matches build.go)
func JniLibsDir(buildDir string, isEjected bool) string {
	if isEjected {
		return filepath.Join(buildDir, "app", "src", "main", "jniLibs")
	}
	// For managed builds, the scaffold creates an "android" subdirectory
	// where the full Android project lives
	return filepath.Join(buildDir, "android", "app", "src", "main", "jniLibs")
}

// Workspace represents a generated build workspace.
type Workspace struct {
	Root       string
	BuildDir   string
	BridgeDir  string
	AndroidDir string
	IOSDir     string
	XtoolDir   string
	Config     *config.Resolved
	Overlay    string
}

// Prepare generates a workspace for the requested platform.
// For ejected platforms, this only prepares bridge files and overlay.
// For managed platforms, this clears and regenerates the full build directory.
func Prepare(root string, cfg *config.Resolved, platform string) (*Workspace, error) {
	ejected := IsEjected(root, platform)

	var buildDir string
	if ejected {
		buildDir = EjectedBuildDir(root, platform)
		fmt.Printf("Using ejected %s project: %s\n", platform, buildDir)
	} else {
		var err error
		buildDir, err = ManagedBuildDir(root, cfg, platform)
		if err != nil {
			return nil, err
		}

		// Only clear and recreate for managed builds
		if err := os.RemoveAll(buildDir); err != nil {
			return nil, fmt.Errorf("failed to clear build directory: %w", err)
		}
		if err := os.MkdirAll(buildDir, 0o755); err != nil {
			return nil, fmt.Errorf("failed to create build directory: %w", err)
		}
	}

	ws := &Workspace{
		Root:       root,
		BuildDir:   buildDir,
		BridgeDir:  BridgeDir(buildDir),
		AndroidDir: filepath.Join(buildDir, "android"),
		IOSDir:     filepath.Join(buildDir, "ios"),
		XtoolDir:   filepath.Join(buildDir, "xtool"),
		Config:     cfg,
		Overlay:    filepath.Join(buildDir, "overlay.json"),
	}

	// For ejected builds, the platform dir IS the build dir
	if ejected {
		switch platform {
		case "android":
			ws.AndroidDir = buildDir
		case "ios":
			ws.IOSDir = buildDir
		case "xtool":
			ws.XtoolDir = buildDir
		}
	}

	if err := os.MkdirAll(ws.BridgeDir, 0o755); err != nil {
		return nil, fmt.Errorf("failed to create bridge directory: %w", err)
	}

	settings := scaffold.Settings{
		AppName:     cfg.AppName,
		AppID:       cfg.AppID,
		Bundle:      cfg.AppID,
		Orientation: cfg.Orientation,
		AllowHTTP:   cfg.AllowHTTP,
		Ejected:     ejected,
	}

	switch platform {
	case "android":
		if err := scaffold.WriteAndroid(buildDir, settings); err != nil {
			return nil, err
		}
	case "ios":
		if err := scaffold.WriteIOS(buildDir, settings); err != nil {
			return nil, err
		}
	case "xtool":
		if err := scaffold.WriteXtool(buildDir, settings); err != nil {
			return nil, err
		}
	default:
		return nil, fmt.Errorf("unknown platform %q", platform)
	}

	if err := WriteBridgeFiles(ws.BridgeDir, cfg); err != nil {
		return nil, err
	}

	if err := WriteOverlay(ws.Overlay, ws.BridgeDir, root); err != nil {
		return nil, err
	}

	return ws, nil
}

// ManagedBuildDir returns the managed build directory for a given project root
// and platform, e.g. ~/.drift/build/<module>/<platform>/<hash>.
func ManagedBuildDir(root string, cfg *config.Resolved, platform string) (string, error) {
	moduleRoot, err := moduleBuildRoot(cfg)
	if err != nil {
		return "", err
	}

	hash := sha1.Sum([]byte(root))
	shortHash := hex.EncodeToString(hash[:6])

	return filepath.Join(moduleRoot, platform, shortHash), nil
}

// BuildRoot returns the cache root for the module.
func BuildRoot(cfg *config.Resolved) (string, error) {
	return moduleBuildRoot(cfg)
}

func moduleBuildRoot(cfg *config.Resolved) (string, error) {
	return cache.BuildRoot(cfg.ModulePath)
}

func WriteBridgeFiles(dir string, cfg *config.Resolved) error {
	bridgeFiles, err := templates.GetBridgeFiles()
	if err != nil {
		return fmt.Errorf("failed to list bridge templates: %w", err)
	}

	data := templates.NewTemplateData(templates.TemplateInput{
		AppName:        cfg.AppName,
		AndroidPackage: cfg.AppID,
		IOSBundleID:    cfg.AppID,
		Orientation:    cfg.Orientation,
		AllowHTTP:      cfg.AllowHTTP,
	})

	for _, file := range bridgeFiles {
		content, err := templates.ReadFile(file)
		if err != nil {
			return fmt.Errorf("failed to read bridge template %s: %w", file, err)
		}

		processed, err := templates.ProcessTemplate(string(content), data)
		if err != nil {
			return fmt.Errorf("failed to render bridge template %s: %w", file, err)
		}

		base := templates.FileName(file)
		if before, ok := strings.CutSuffix(base, ".tmpl"); ok {
			base = before
		}

		destFile := filepath.Join(dir, base)
		if err := os.WriteFile(destFile, []byte(processed), 0o644); err != nil {
			return fmt.Errorf("failed to write bridge file %s: %w", destFile, err)
		}
	}

	return nil
}

func WriteOverlay(overlayPath, bridgeDir, projectRoot string) error {
	bridgeFiles, err := templates.GetBridgeFiles()
	if err != nil {
		return fmt.Errorf("failed to list bridge templates: %w", err)
	}

	replace := make(map[string]string, len(bridgeFiles))
	for _, file := range bridgeFiles {
		base := templates.FileName(file)
		if before, ok := strings.CutSuffix(base, ".tmpl"); ok {
			base = before
		}
		virtualName := "drift_bridge_" + base
		replace[filepath.Join(projectRoot, virtualName)] = filepath.Join(bridgeDir, base)
	}

	payload := map[string]map[string]string{
		"Replace": replace,
	}

	data, err := json.Marshal(payload)
	if err != nil {
		return fmt.Errorf("failed to marshal overlay: %w", err)
	}

	if err := os.WriteFile(overlayPath, data, 0o644); err != nil {
		return fmt.Errorf("failed to write overlay: %w", err)
	}

	return nil
}
